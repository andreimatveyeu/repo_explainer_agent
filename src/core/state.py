from typing import List, Dict, Any, Optional
from typing_extensions import TypedDict, NotRequired # For Python < 3.11 compatibility with NotRequired

from .models import AbstractCodeKnowledgeBase # Assuming models.py is in the same directory

# Forward declaration for ToolCall if it's complex and defined elsewhere,
# or define a simple structure here if sufficient.
class ToolCall(TypedDict):
    tool_name: str
    tool_input: Dict[str, Any]
    # Potentially tool_id for tracking calls

class RepoExplainerState(TypedDict):
    """
    Represents the overall state of the Repository Explainer Agent.
    This state is passed between and updated by LangGraph nodes.
    """

    # Repository and Query Information
    repo_url: NotRequired[str]
    local_repo_path: NotRequired[str]
    user_query: str # Current user query, should be present when processing a query
    
    # Core Knowledge and Summaries
    overall_summary: NotRequired[str] # High-level summary of the repository
    file_summaries: NotRequired[Dict[str, str]] # Path: summary, for individual files
    abstract_code_kb: NotRequired[AbstractCodeKnowledgeBase] # Structured knowledge of the code
    parsed_documentation: NotRequired[Dict[str, str]] # File_path: doc_content
    commit_insights: NotRequired[List[str]] # Key insights from commit history
    
    # Agent's Focus and History
    current_focus_path: NotRequired[str] # File/directory user is currently asking about
    current_focus_entity_id: NotRequired[str] # ID of the CodeEntity user is focused on
    explanation_history: NotRequired[List[Dict[str, str]]] # List of {"query": user_query, "explanation": agent_response}
    
    # Processing and Output
    generated_explanation: NotRequired[str] # The explanation generated by the current step/node
    visualizations: NotRequired[Dict[str, str]] # E.g., { "dependency_graph_dot": "digraph G {...}" }
    
    # Agent Internals and Control Flow
    parsed_query_intent: NotRequired[str] # Intent derived from user_query
    target_entity_ids: NotRequired[List[str]] # IDs of entities targeted by the query
    action_plan: NotRequired[List[str]] # Sequence of nodes/actions planned by user_query_parser
    clarification_question_needed: NotRequired[bool] # Flag if agent needs to ask a question
    
    # Tool Usage (aligns with LangChain's tool calling)
    tool_calls: NotRequired[List[ToolCall]] # Tool calls requested by an LLM
    # tool_outputs: NotRequired[List[Dict[str, Any]]] # Outputs from tool executions, if needed directly in state

    # Configuration and Errors
    repo_config: NotRequired[Dict[str, Any]] # E.g., detected_languages, project_type
    error_message: NotRequired[str] # If an error occurred in the last step
    
    # Potentially, a list of available tools if dynamically determined, though often static
    # available_tools: NotRequired[List[str]] 

    # To manage graph execution, e.g., for conditional routing based on complex logic
    # next_node_override: NotRequired[str]
